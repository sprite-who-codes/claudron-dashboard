<!--
  ============================================================================
  File:     dashboard/index.html
  Purpose:  Claudron Dashboard ‚Äî "Claudron lives here"

  The main display for a 7" screen (1024√ó600). Shows Claudron's sprite in
  whatever room he's currently in, with mood-based face rendering, speech
  bubble for status text, and smooth animations.

  Polls /api/state every 2s for mood, status, room, and location changes.
  Polls /api/room/{room} when the room changes to get location configs.

  External Dependencies:
    /js/claudron-face.js                ‚Äî Shared face rendering (renderFace)
    /sprites/body-final-transparent.png ‚Äî Sprite body image
    /rooms/{room}/wallpaper.png         ‚Äî Room background images
  ============================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claudron</title>
<style>
  /* ===== Reset & Base ===== */
  * { margin: 0; padding: 0; box-sizing: border-box; }
  .cursor-hidden, .cursor-hidden * { cursor: none !important; }
  body {
    background: #0f0f0f;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  /* ===== Mobile Portrait Mode ===== */
  @media (max-aspect-ratio: 1/1) {
    body {
      overflow: hidden;
    }
  }

  /* ===== Pixel Font ===== */
  @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

  /* ===== Top Decorative Border =====
     Cozy cottage shelf with pixel art items ‚Äî vines, books, potions.
     Fills the black bar above the room. */
  #top-border {
    width: 100%;
    max-width: 1584px;
    height: 83px;
    background: #1a1208;
    position: relative;
    overflow: hidden;
    image-rendering: pixelated;
    flex-shrink: 0;
    z-index: 20;
  }

  @media (max-aspect-ratio: 1/1) {
    #top-border {
      position: fixed;
      top: 0;
      left: 0;
      max-width: 100%;
      height: 50px;
      z-index: 20;
    }
    #top-border .shelf-items { height: 38px; }
    #top-border .book { transform: scale(0.7); transform-origin: bottom; }
    #top-border .potion { transform: scale(0.7); transform-origin: bottom; }
    #top-border .candle { transform: scale(0.7); transform-origin: bottom; }
    #top-border .crystal-ball { transform: scale(0.7); transform-origin: bottom; }
    #top-border .plant { transform: scale(0.7); transform-origin: bottom; }
    #top-border .skull { font-size: 14px; }
    #top-border .vine { font-size: 16px; }
  }

  /* Wooden shelf base */
  #top-border::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 8px;
    background: linear-gradient(to bottom, #8B6914, #6B4F10, #4A3508);
    box-shadow: 0 2px 4px rgba(0,0,0,0.6);
  }

  /* Shelf top highlight */
  #top-border::before {
    content: '';
    position: absolute;
    bottom: 8px;
    left: 0;
    right: 0;
    height: 2px;
    background: #A67C1A;
    z-index: 1;
  }

  /* Shelf items container */
  .shelf-items {
    position: absolute;
    bottom: 10px;
    left: 0;
    right: 0;
    height: 70px;
    display: flex;
    align-items: flex-end;
    justify-content: space-around;
    padding: 0 20px;
  }

  /* Individual shelf item base */
  .shelf-item {
    position: relative;
    image-rendering: pixelated;
    flex-shrink: 0;
  }

  /* --- Pixel art book cluster --- */
  .books {
    display: flex;
    align-items: flex-end;
    gap: 2px;
  }
  .book {
    width: 8px;
    border-radius: 1px 1px 0 0;
  }
  .book-red { height: 28px; background: #C0392B; border-left: 2px solid #A93226; }
  .book-blue { height: 32px; background: #2E86C1; border-left: 2px solid #2471A3; }
  .book-green { height: 26px; background: #27AE60; border-left: 2px solid #1E8449; }
  .book-purple { height: 30px; background: #8E44AD; border-left: 2px solid #7D3C98; }
  .book-brown { height: 24px; background: #A0522D; border-left: 2px solid #8B4513; }
  .book-teal { height: 34px; background: #17A589; border-left: 2px solid #148F77; }
  .book-tilted {
    width: 8px;
    height: 30px;
    background: #D4AC0D;
    border-left: 2px solid #B7950B;
    transform: rotate(15deg);
    transform-origin: bottom right;
    margin-right: 4px;
  }

  /* --- Pixel art potion bottles --- */
  .potion {
    width: 14px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .potion-neck {
    width: 6px;
    height: 8px;
    border-radius: 2px 2px 0 0;
  }
  .potion-body {
    width: 14px;
    height: 18px;
    border-radius: 0 0 4px 4px;
  }
  .potion-cork {
    width: 8px;
    height: 4px;
    background: #A0522D;
    border-radius: 2px 2px 0 0;
  }
  .potion-green .potion-neck { background: rgba(46, 204, 113, 0.6); }
  .potion-green .potion-body { background: #2ECC71; box-shadow: 0 0 6px rgba(46, 204, 113, 0.5); }
  .potion-purple .potion-neck { background: rgba(155, 89, 182, 0.6); }
  .potion-purple .potion-body { background: #9B59B6; box-shadow: 0 0 6px rgba(155, 89, 182, 0.5); }
  .potion-blue .potion-neck { background: rgba(52, 152, 219, 0.6); }
  .potion-blue .potion-body { background: #3498DB; box-shadow: 0 0 6px rgba(52, 152, 219, 0.4); }
  .potion-red .potion-neck { background: rgba(231, 76, 60, 0.6); }
  .potion-red .potion-body { background: #E74C3C; box-shadow: 0 0 6px rgba(231, 76, 60, 0.4); }

  /* --- Vine decorations --- */
  .vine {
    position: absolute;
    color: #27AE60;
    font-size: 24px;
    top: 8px;
    text-shadow: 0 0 4px rgba(39, 174, 96, 0.3);
  }
  .vine-left { left: 8px; }
  .vine-right { right: 8px; transform: scaleX(-1); }

  /* --- Candle --- */
  .candle {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .candle-flame {
    width: 6px;
    height: 10px;
    background: #F39C12;
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    box-shadow: 0 0 8px #F39C12, 0 0 16px rgba(243, 156, 18, 0.4);
    animation: flicker 1.5s ease-in-out infinite alternate;
  }
  .candle-wax {
    width: 10px;
    height: 22px;
    background: #F5E6CA;
    border-radius: 2px;
  }
  .candle-holder {
    width: 16px;
    height: 4px;
    background: #8B6914;
    border-radius: 0 0 2px 2px;
  }

  @keyframes flicker {
    0% { transform: scaleY(1) scaleX(1); opacity: 1; }
    25% { transform: scaleY(1.1) scaleX(0.9); }
    50% { transform: scaleY(0.9) scaleX(1.1); opacity: 0.85; }
    75% { transform: scaleY(1.05) scaleX(0.95); }
    100% { transform: scaleY(0.95) scaleX(1.05); opacity: 0.9; }
  }

  /* --- Crystal ball --- */
  .crystal-ball {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .crystal-orb {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, rgba(155, 89, 182, 0.3), #2C1A4A 70%);
    border: 2px solid #7D3C98;
    box-shadow: 0 0 10px rgba(155, 89, 182, 0.4), inset 0 0 8px rgba(155, 89, 182, 0.2);
    animation: crystalGlow 3s ease-in-out infinite;
  }
  .crystal-base {
    width: 18px;
    height: 6px;
    background: #8B6914;
    border-radius: 0 0 4px 4px;
    margin-top: -2px;
  }

  @keyframes crystalGlow {
    0%, 100% { box-shadow: 0 0 10px rgba(155, 89, 182, 0.4), inset 0 0 8px rgba(155, 89, 182, 0.2); }
    50% { box-shadow: 0 0 16px rgba(155, 89, 182, 0.7), inset 0 0 12px rgba(155, 89, 182, 0.4); }
  }

  /* --- Skull decoration --- */
  .skull {
    font-size: 20px;
    filter: grayscale(0.3);
  }

  /* --- Plant --- */
  .plant {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .plant-leaves {
    font-size: 18px;
    line-height: 1;
    margin-bottom: -4px;
  }
  .plant-pot {
    width: 16px;
    height: 12px;
    background: #A0522D;
    border-radius: 0 0 4px 4px;
    border-top: 2px solid #8B4513;
  }

  /* ===== Bottom HUD Strip =====
     Retro game stats panel with live info. */
  #bottom-hud {
    width: 100%;
    max-width: 1584px;
    height: 83px;
    background: linear-gradient(to bottom, #1a1412, #0f0d0b);
    border-top: 2px solid #3d2e1f;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 24px;
    font-family: 'VT323', monospace;
    color: #c8b89a;
    position: relative;
    z-index: 20;
  }

  @media (max-aspect-ratio: 1/1) {
    #bottom-hud {
      position: fixed;
      bottom: 0;
      left: 0;
      max-width: 100%;
      z-index: 20;
      height: 60px;
      padding: 0 8px;
      gap: 0;
    }
    #bottom-hud .hud-label { font-size: 10px; letter-spacing: 1px; }
    #bottom-hud .hud-value { font-size: 18px; }
    #bottom-hud .hud-value-small { font-size: 14px; }
    #bottom-hud .hud-mood { font-size: 24px; }
    #bottom-hud .hud-room { font-size: 16px; }
    #bottom-hud .hud-weather-icon { font-size: 20px; }
    #bottom-hud .hud-weather-temp { font-size: 18px; }
    #bottom-hud .hud-divider { height: 30px; }
  }

  /* HUD decorative top edge */
  #bottom-hud::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg,
      transparent 0%, #6B4F10 10%, #A67C1A 30%,
      #A67C1A 70%, #6B4F10 90%, transparent 100%
    );
  }

  /* HUD section containers */
  .hud-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
  }

  .hud-label {
    font-size: 14px;
    color: #6b5d4d;
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  .hud-value {
    font-size: 28px;
    color: #e8d8c0;
    text-shadow: 0 0 6px rgba(232, 216, 192, 0.3);
  }

  .hud-value-small {
    font-size: 20px;
    color: #c8b89a;
  }

  /* Mood emoji display */
  .hud-mood {
    font-size: 36px;
    line-height: 1;
    filter: drop-shadow(0 0 4px rgba(155, 89, 182, 0.4));
  }

  /* Room name with accent color */
  .hud-room {
    font-size: 24px;
    color: #A78BFA;
    text-shadow: 0 0 8px rgba(167, 139, 250, 0.3);
  }

  /* Weather section */
  .hud-weather {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .hud-weather-icon {
    font-size: 28px;
  }
  .hud-weather-temp {
    font-size: 24px;
    color: #e8d8c0;
  }

  /* Divider lines between HUD sections */
  .hud-divider {
    width: 1px;
    height: 50px;
    background: linear-gradient(to bottom, transparent, #3d2e1f, transparent);
  }

  /* ===== Room Container =====
     Maintains native wallpaper aspect ratio (1584√ó672 ‚Üí 42.42%).
     Fills width, centered vertically. Now flanked by borders. */
  #room-container {
    position: relative;
    width: 100%;
    max-width: 1584px;
    flex: 1;
    min-height: 0;
  }
  #room-wallpaper {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    transition: opacity 0.5s ease;
  }

  @media (max-aspect-ratio: 1/1) {
    #room-container {
      position: fixed;
      top: 50px;
      left: 0;
      width: 100vw;
      max-width: 100vw;
      height: calc(100vh - 110px);
      overflow-x: scroll;
      overflow-y: hidden;
      flex: none;
      -webkit-overflow-scrolling: touch;
    }
    #room-wallpaper {
      position: relative;
      height: 100%;
      width: auto;
      object-fit: contain;
    }
  }

  /* ===== Sprite Anchor =====
     Absolutely positioned within room container.
     Transitions smoothly when location changes. */
  #sprite-anchor {
    position: absolute;
    display: none;
    flex-direction: column;
    align-items: center;
    transition: left 0.6s ease, top 0.6s ease;
  }

  /* ===== Speech Bubble (Stardew/Animal Crossing style) ===== */
  #speech-bubble {
    position: absolute;
    z-index: 10;
    background: rgba(245, 240, 230, 0.95);
    border: 2.5px solid #8B6FCF;
    border-radius: 14px;
    padding: 7px 14px;
    max-width: 400px;
    white-space: nowrap;
    left: 50%;
    transform: translateX(-50%);
    bottom: calc(100% + 8px);
    font-family: 'VT323', monospace;
    font-size: 12px;
    letter-spacing: 0.5px;
    line-height: 1.3;
    color: #2a1a3e;
    text-align: center;
    box-shadow: 0 2px 8px rgba(139, 111, 207, 0.3), inset 0 0 0 1px rgba(255,255,255,0.3);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  #speech-bubble.visible { opacity: 1; }
  /* Cute rounded tail */
  #speech-bubble::after {
    content: '';
    position: absolute;
    bottom: -7px;
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    width: 10px; height: 10px;
    background: rgba(245, 240, 230, 0.95);
    border-right: 2.5px solid #8B6FCF;
    border-bottom: 2.5px solid #8B6FCF;
  }

  /* ===== Sprite Wrapper ===== */
  #sprite-wrap {
    position: relative;
    width: 200px;
    height: 183px;
    transform-origin: top center;
  }
  #sprite-wrap img {
    position: absolute;
    top: 0; left: 0;
    width: 200px; height: 183px;
  }
  #face-container {
    position: absolute;
    top: 0; left: 0;
    width: 200px; height: 183px;
    pointer-events: none;
  }

  /* ===== Animations ===== */
  @keyframes bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
  }
  @keyframes glowGreen {
    0%, 100% { filter: drop-shadow(0 0 8px rgba(74, 222, 128, 0.65)); }
    50% { filter: drop-shadow(0 0 18px rgba(74, 222, 128, 0.85)); }
  }
  @keyframes glowRed {
    0%, 100% { filter: drop-shadow(0 0 8px rgba(255, 68, 68, 0.65)); }
    50% { filter: drop-shadow(0 0 18px rgba(255, 68, 68, 0.85)); }
  }

  /* Mood-based sprite states */
  .mood-normal #sprite-anchor { animation: bob 3s ease-in-out infinite; }
  .mood-normal #sprite-wrap  { animation: glowGreen 3s ease-in-out infinite; }

  .mood-angry #sprite-anchor { animation: bob 3s ease-in-out infinite; }
  .mood-angry #sprite-wrap   { animation: glowRed 3s ease-in-out infinite; }

  .mood-sleeping #sprite-anchor { animation: none; }
  .mood-sleeping #sprite-wrap   { animation: none; filter: none; opacity: 0.6; }

  /* (touch reaction animations removed ‚Äî Claudron decides reactions server-side) */

  /* ===== Editor Toggle ===== */
  .corner-btn {
    position: fixed;
    bottom: 95px;
    width: 36px;
    height: 36px;
    background: rgba(30, 30, 30, 0.7);
    border: 1px solid #333;
    border-radius: 50%;
    color: #888;
    font-size: 18px;
    cursor: pointer;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    transition: opacity 0.3s;
    opacity: 0.4;
  }
  .corner-btn:hover { opacity: 1; }
  #editor-btn { right: 10px; }
  #fullscreen-btn { right: 54px; }
</style>
</head>
<body>

<!-- ===== Top Decorative Border ‚Äî Cozy Cottage Shelf ===== -->
<div id="top-border">
  <span class="vine vine-left">üåø</span>
  <span class="vine vine-right">üåø</span>
  <div class="shelf-items">
    <!-- Left cluster: plant + books -->
    <div class="shelf-item plant">
      <div class="plant-leaves">üå±</div>
      <div class="plant-pot"></div>
    </div>
    <div class="shelf-item books">
      <div class="book book-tilted"></div>
      <div class="book book-red"></div>
      <div class="book book-blue"></div>
      <div class="book book-green"></div>
    </div>
    <div class="shelf-item potion potion-green">
      <div class="potion-cork"></div>
      <div class="potion-neck"></div>
      <div class="potion-body"></div>
    </div>
    <!-- Center cluster: candle + crystal ball -->
    <div class="shelf-item candle">
      <div class="candle-flame"></div>
      <div class="candle-wax"></div>
      <div class="candle-holder"></div>
    </div>
    <div class="shelf-item books">
      <div class="book book-purple"></div>
      <div class="book book-brown"></div>
      <div class="book book-teal"></div>
    </div>
    <div class="shelf-item crystal-ball">
      <div class="crystal-orb"></div>
      <div class="crystal-base"></div>
    </div>
    <div class="shelf-item potion potion-purple">
      <div class="potion-cork"></div>
      <div class="potion-neck"></div>
      <div class="potion-body"></div>
    </div>
    <!-- Right cluster: skull + books + potions -->
    <div class="shelf-item skull">üíÄ</div>
    <div class="shelf-item books">
      <div class="book book-red"></div>
      <div class="book book-purple"></div>
      <div class="book book-tilted"></div>
    </div>
    <div class="shelf-item potion potion-blue">
      <div class="potion-cork"></div>
      <div class="potion-neck"></div>
      <div class="potion-body"></div>
    </div>
    <div class="shelf-item candle">
      <div class="candle-flame"></div>
      <div class="candle-wax"></div>
      <div class="candle-holder"></div>
    </div>
    <div class="shelf-item potion potion-red">
      <div class="potion-cork"></div>
      <div class="potion-neck"></div>
      <div class="potion-body"></div>
    </div>
    <div class="shelf-item plant">
      <div class="plant-leaves">ü™¥</div>
      <div class="plant-pot"></div>
    </div>
  </div>
</div>

<!-- ===== Room View ===== -->
<div id="room-container">
  <img id="room-wallpaper" src="" alt="">
  <div id="sprite-anchor">
    <div id="speech-bubble"></div>
    <div id="sprite-wrap">
      <img id="sprite" src="/sprites/body-final-transparent.png" alt="">
      <div id="face-container"></div>
    </div>
  </div>
</div>

<!-- ===== Bottom HUD ‚Äî Retro Game Stats Panel ===== -->
<div id="bottom-hud">
  <div class="hud-section">
    <div class="hud-label">Time</div>
    <div class="hud-value" id="hud-time">--:--</div>
    <div class="hud-value-small" id="hud-date">---</div>
  </div>
  <div class="hud-divider"></div>
  <div class="hud-section">
    <div class="hud-label">Weather</div>
    <div class="hud-weather">
      <span class="hud-weather-icon" id="hud-weather-icon">üå§Ô∏è</span>
      <span class="hud-weather-temp" id="hud-weather-temp">--¬∞</span>
    </div>
  </div>
  <div class="hud-divider"></div>
  <div class="hud-section">
    <div class="hud-label">Mood</div>
    <div class="hud-mood" id="hud-mood">üò¥</div>
  </div>
  <div class="hud-divider"></div>
  <div class="hud-section">
    <div class="hud-label">Room</div>
    <div class="hud-room" id="hud-room">---</div>
  </div>
</div>

<!-- Controls -->
<button id="fullscreen-btn" class="corner-btn" title="Toggle Fullscreen">‚õ∂</button>
<a id="editor-btn" class="corner-btn" href="/editor.html" title="Open Editor">‚öôÔ∏è</a>

<script src="/js/claudron-face.js"></script>
<script>
  // =========================================================================
  //  Constants & State
  // =========================================================================
  const NATIVE_W = 1584, SPRITE_NATIVE = 250;

  let currentRoom = null;
  let currentLoc = null;
  let currentMood = null;
  let currentStatus = null;
  let roomConfig = null;

  // DOM refs
  const container = document.getElementById('room-container');
  const wallpaper = document.getElementById('room-wallpaper');
  const anchor    = document.getElementById('sprite-anchor');
  const wrap      = document.getElementById('sprite-wrap');
  const faceCtr   = document.getElementById('face-container');
  const bubble    = document.getElementById('speech-bubble');

  // =========================================================================
  //  Mood Class Management
  // =========================================================================

  /** Apply the correct mood class to <body> for CSS animation control. */
  function applyMoodClass(mood) {
    document.body.className = '';
    if (mood === 'sleeping') {
      document.body.classList.add('mood-sleeping');
    } else if (mood === 'angry') {
      document.body.classList.add('mood-angry');
    } else {
      document.body.classList.add('mood-normal');
    }
  }

  // =========================================================================
  //  Sprite Positioning
  // =========================================================================

  /**
   * Resolve a location name to its config, with fallback logic:
   * 1. Exact match in locations
   * 2. Room's "default" field
   * 3. First location in the locations object
   */
  function resolveLocation(locName, cfg) {
    const locs = cfg?.locations;
    if (!locs) return null;
    if (locs[locName]) return locs[locName];
    if (cfg.default && locs[cfg.default]) return locs[cfg.default];
    const keys = Object.keys(locs);
    return keys.length ? locs[keys[0]] : null;
  }

  /**
   * Position the sprite at a location from the room config.
   * Uses the exact positioning math from the spec.
   */
  /** Check if we're in mobile portrait mode */
  function isMobilePortrait() {
    return window.innerWidth / window.innerHeight < 1;
  }

  function positionSprite(loc) {
    if (!loc) { anchor.style.display = 'none'; return; }

    // In mobile portrait, use wallpaper's actual rendered dimensions
    let containerWidth, containerHeight;
    if (isMobilePortrait()) {
      containerWidth = wallpaper.offsetWidth;
      containerHeight = wallpaper.offsetHeight;
    } else {
      containerWidth = container.offsetWidth;
      containerHeight = container.offsetHeight;
    }

    const spritePct = SPRITE_NATIVE / NATIVE_W * 100;
    const scale = (containerWidth * spritePct / 100) / 200;
    const scaledW = 200 * scale;
    const scaledH = 183 * scale;

    const facing = loc.facing || 'right';
    const rotation = loc.rotation || 0;

    // In mobile portrait, use pixel positions since container scrolls
    if (isMobilePortrait()) {
      const px = loc.x * containerWidth;
      const py = loc.y * containerHeight;
      anchor.style.display = 'flex';
      anchor.style.left = `${px - scaledW / 2}px`;
      anchor.style.top = `${py - scaledH}px`;
    } else {
      anchor.style.display = 'flex';
      anchor.style.left = `calc(${loc.x * 100}% - ${scaledW / 2}px)`;
      anchor.style.top = `calc(${loc.y * 100}% - ${scaledH}px)`;
    }
    wrap.style.transform = `scale(${scale})${facing === 'left' ? ' scaleX(-1)' : ''}${rotation ? ` rotate(${rotation}deg)` : ''}`;
    wrap.style.transformOrigin = 'top center';

    // Auto-scroll to center sprite on mobile
    if (isMobilePortrait()) {
      const px = loc.x * containerWidth;
      const scrollTarget = px - (container.clientWidth / 2);
      container.scrollTo({ left: Math.max(0, scrollTarget), behavior: 'smooth' });
    }
  }

  // =========================================================================
  //  Speech Bubble
  // =========================================================================

  function updateBubble(status) {
    if (status) {
      bubble.textContent = status;
      bubble.classList.add('visible');
    } else {
      bubble.classList.remove('visible');
    }
  }

  // =========================================================================
  //  Room Loading
  // =========================================================================

  async function loadRoom(room) {
    wallpaper.src = `/rooms/${room}/wallpaper.png`;
    try {
      const res = await fetch(`/api/room/${room}`);
      roomConfig = await res.json();
    } catch {
      roomConfig = { locations: {} };
    }
  }

  // =========================================================================
  //  State Polling ‚Äî every 2 seconds
  // =========================================================================

  async function pollState() {
    try {
      const res = await fetch('/api/state');
      const state = await res.json();

      // Room changed? Reload room config
      if (state.room !== currentRoom) {
        currentRoom = state.room;
        await loadRoom(currentRoom);
      }

      // Location changed? Reposition sprite
      if (state.location !== currentLoc) {
        currentLoc = state.location;
        const loc = resolveLocation(currentLoc, roomConfig);
        positionSprite(loc || null);
      }

      // Mood changed? Update face + animations
      if (state.mood !== currentMood) {
        currentMood = state.mood;
        applyMoodClass(currentMood);
        renderFace(faceCtr, currentMood);
      }

      // Status changed? Update speech bubble
      if (state.status !== currentStatus) {
        currentStatus = state.status;
        updateBubble(currentStatus);
      }

      // Update HUD with current mood and room
      updateHud(state.mood, state.room);
    } catch {
      // Silent fail ‚Äî retry next poll
    }
  }

  // =========================================================================
  //  Resize Handler ‚Äî reposition sprite when window resizes
  // =========================================================================
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      const loc = resolveLocation(currentLoc, roomConfig);
      if (loc) positionSprite(loc);
    }, 100);
  });

  // =========================================================================
  //  Fullscreen Toggle
  // =========================================================================
  const fsBtn = document.getElementById('fullscreen-btn');
  fsBtn.addEventListener('click', () => {
    const el = document.documentElement;
    const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
    if (!isFullscreen) {
      (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen).call(el).catch(e => console.error('Fullscreen error:', e));
    } else {
      (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document).catch(e => console.error('Exit fullscreen error:', e));
    }
  });
  ['fullscreenchange', 'webkitfullscreenchange'].forEach(evt =>
  document.addEventListener(evt, () => {
    const isFs = document.fullscreenElement || document.webkitFullscreenElement;
    fsBtn.textContent = isFs ? '‚õ∂' : '‚õ∂';
    // Hide controls in fullscreen after a delay, show on mouse move
    if (isFs) {
      fsBtn.style.opacity = '0';
      document.getElementById('editor-btn').style.opacity = '0';
      document.body.classList.add('cursor-hidden');
    } else {
      fsBtn.style.opacity = '';
      document.getElementById('editor-btn').style.opacity = '';
      document.body.classList.remove('cursor-hidden');
    }
    // Reposition sprite after fullscreen transition settles
    setTimeout(() => {
      const loc = resolveLocation(currentLoc, roomConfig);
      if (loc) positionSprite(loc);
    }, 300);
  }));
  // Show controls on mouse move in fullscreen
  let hideTimer;
  document.addEventListener('mousemove', () => {
    const isFs = document.fullscreenElement || document.webkitFullscreenElement;
    if (isFs) {
      document.body.classList.remove('cursor-hidden');
      fsBtn.style.opacity = '0.4';
      document.getElementById('editor-btn').style.opacity = '0.4';
      clearTimeout(hideTimer);
      hideTimer = setTimeout(() => {
        const stillFs = document.fullscreenElement || document.webkitFullscreenElement;
        if (stillFs) {
          fsBtn.style.opacity = '0';
          document.getElementById('editor-btn').style.opacity = '0';
          document.body.classList.add('cursor-hidden');
        }
      }, 2000);
    }
  });

  // =========================================================================
  //  HUD ‚Äî Bottom Info Strip
  // =========================================================================

  const MOOD_EMOJI = {
    happy: 'üòä', thinking: 'ü§î', sleeping: 'üò¥', angry: 'üò†',
    excited: 'ü§©', sad: 'üò¢', focused: 'üéØ', coding: 'üíª',
    curious: 'üßê', proud: 'üò§', mischievous: 'üòè', cozy: '‚òï',
    grateful: 'ü•π', vulnerable: 'ü•∫', overwhelmed: 'üòµ‚Äçüí´',
    lonely: 'üòî', embarrassed: 'üò≥', protective: 'üõ°Ô∏è',
    awe: 'ü§Ø', jealous: 'üòí', defiant: 'üòà'
  };

  const hudTime = document.getElementById('hud-time');
  const hudDate = document.getElementById('hud-date');
  const hudMood = document.getElementById('hud-mood');
  const hudRoom = document.getElementById('hud-room');

  /** Update the HUD clock every second. */
  function updateClock() {
    const now = new Date();
    const h = now.getHours();
    const m = String(now.getMinutes()).padStart(2, '0');
    const ampm = h >= 12 ? 'PM' : 'AM';
    const h12 = h % 12 || 12;
    hudTime.textContent = `${h12}:${m} ${ampm}`;

    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    hudDate.textContent = `${days[now.getDay()]} ${months[now.getMonth()]} ${now.getDate()}`;
  }

  /** Update HUD mood and room from state data. */
  function updateHud(mood, room) {
    hudMood.textContent = MOOD_EMOJI[mood] || 'üîÆ';
    hudRoom.textContent = room || '---';
  }

  // Start clock
  updateClock();
  setInterval(updateClock, 1000);

  // =========================================================================
  //  Weather Polling ‚Äî every 15 minutes
  // =========================================================================

  const hudWeatherIcon = document.getElementById('hud-weather-icon');
  const hudWeatherTemp = document.getElementById('hud-weather-temp');

  async function pollWeather() {
    try {
      const res = await fetch('/api/weather');
      const data = await res.json();
      if (data.temp_f !== null && data.temp_f !== undefined) {
        hudWeatherIcon.textContent = data.icon || 'üå°Ô∏è';
        hudWeatherTemp.textContent = `${data.temp_f}¬∞`;
      }
    } catch {
      // Keep showing previous value or "--¬∞"
    }
  }

  // =========================================================================
  //  Touch / Click System
  //
  //  Distinguishes single click vs double-click via a 300ms timer:
  //  - Single click on sprite ‚Üí POST /api/touch {type:'click'} ‚Üí
  //    server picks a random instant reaction, no agent wake
  //  - Double-click on sprite ‚Üí POST /api/touch {type:'doubleclick'} ‚Üí
  //    server fires an OpenClaw wake event (throttled 30s/user)
  //  - Clicks off-sprite are logged but don't trigger reactions
  //
  //  The server also checks known-ips.json ‚Äî if the visitor's IP is
  //  unknown and they tap the sprite, the response includes
  //  {needsIdentify: true}, which triggers the emoji identity prompt
  //  (üßπ Miranda, üõª Ryan, üëª Guest). Selection POSTs to /api/identify
  //  and is cached in localStorage so it only shows once per device.
  // =========================================================================

  let _clickTimer = null;
  let _clickCount = 0;

  /** Check if a click point is within the sprite-anchor bounding box. */
  function isOnSprite(clientX, clientY) {
    const rect = anchor.getBoundingClientRect();
    return rect.width > 0 && clientX >= rect.left && clientX <= rect.right &&
           clientY >= rect.top && clientY <= rect.bottom;
  }

  /** Send click/doubleclick to server. */
  async function sendTouch(type, x, y, onSprite) {
    try {
      const res = await fetch('/api/touch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type, x, y, onSprite })
      });
      const data = await res.json();
      // Show identify modal only if server says so AND not already identified this session
      if (data.needsIdentify && !localStorage.getItem('claudron-identified')) {
        showIdentifyButtons();
      }
    } catch {}
  }

  // =========================================================================
  //  Emoji Identification Buttons
  // =========================================================================

  let _identifyOverlay = null;

  function showIdentifyButtons() {
    if (_identifyOverlay) return; // already showing

    // Backdrop ‚Äî dark overlay covering the whole room (keeps it modal)
    const backdrop = document.createElement('div');
    backdrop.id = 'identify-overlay';
    backdrop.style.cssText = `
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 50; background: transparent;
    `;

    // Speech-bubble-style prompt positioned relative to sprite
    const prompt = document.createElement('div');
    prompt.id = 'identify-prompt';
    prompt.style.cssText = `
      position: absolute; z-index: 51;
      display: flex; flex-direction: column; align-items: center; gap: 10px;
      transition: left 0.3s ease, top 0.3s ease;
    `;

    // Title
    const title = document.createElement('div');
    title.textContent = 'who\'s there?';
    title.style.cssText = `
      font-family: 'VT323', monospace; font-size: 28px; color: #e8d8c0;
      text-shadow: 0 0 8px rgba(139, 111, 207, 0.5); letter-spacing: 2px;
    `;
    prompt.appendChild(title);

    // Button row
    const row = document.createElement('div');
    row.style.cssText = 'display: flex; gap: 16px;';

    const mobile = isMobilePortrait();
    const btnSize = mobile ? 'width:90px;height:110px;' : 'width:120px;height:140px;';
    const emojiSize = mobile ? '50px' : '80px';
    const labelSize = mobile ? '14px' : '18px';

    const choices = [
      { emoji: 'üßπ', who: 'miranda', label: 'Miranda' },
      { emoji: 'üõª', who: 'ryan',    label: 'Ryan' },
      { emoji: 'üëª', who: 'guest',   label: 'Guest' },
    ];

    choices.forEach(({ emoji, who, label }) => {
      const btn = document.createElement('button');
      btn.innerHTML = `<span style="font-size:${emojiSize};line-height:1">${emoji}</span><br><span style="font-family:'VT323',monospace;font-size:${labelSize};color:#c8b89a;letter-spacing:1px">${label}</span>`;
      btn.style.cssText = `
        ${btnSize} padding: 10px 0 6px;
        background: rgba(30, 20, 50, 0.85);
        border: 2px solid rgba(139, 111, 207, 0.5);
        border-radius: 18px; cursor: pointer;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        transition: transform 0.15s, background 0.15s, box-shadow 0.15s;
        box-shadow: 0 4px 16px rgba(0,0,0,0.5), 0 0 12px rgba(139, 111, 207, 0.15);
        -webkit-tap-highlight-color: transparent;
      `;
      btn.addEventListener('mouseenter', () => {
        btn.style.transform = 'scale(1.1)';
        btn.style.background = 'rgba(139, 111, 207, 0.35)';
        btn.style.boxShadow = '0 4px 20px rgba(0,0,0,0.5), 0 0 24px rgba(139, 111, 207, 0.4)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.transform = 'scale(1)';
        btn.style.background = 'rgba(30, 20, 50, 0.85)';
        btn.style.boxShadow = '0 4px 16px rgba(0,0,0,0.5), 0 0 12px rgba(139, 111, 207, 0.15)';
      });
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        localStorage.setItem('claudron-identified', who);
        fetch('/api/identify', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ who, emoji })
        }).catch(() => {});
        backdrop.remove();
        prompt.remove();
        _identifyOverlay = null;
      });
      row.appendChild(btn);
    });

    prompt.appendChild(row);

    // Tail / pointer triangle pointing down toward the sprite
    const tail = document.createElement('div');
    tail.style.cssText = `
      width: 0; height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-top: 12px solid rgba(139, 111, 207, 0.5);
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
    `;
    prompt.appendChild(tail);

    // Position the prompt above the sprite (like the speech bubble)
    function positionPrompt() {
      const spriteRect = anchor.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      if (spriteRect.width === 0) {
        // Sprite not visible ‚Äî fallback to center
        prompt.style.left = '50%';
        prompt.style.top = '30%';
        prompt.style.transform = 'translateX(-50%)';
        return;
      }

      // Sprite center relative to container
      const spriteCenterX = (spriteRect.left + spriteRect.width / 2) - containerRect.left + container.scrollLeft;
      const spriteTopY = spriteRect.top - containerRect.top;

      // Measure the prompt (need it in DOM first)
      const promptW = prompt.offsetWidth || 400;
      const promptH = prompt.offsetHeight || 200;

      // Place above sprite, centered horizontally
      let left = spriteCenterX - promptW / 2;
      let top = spriteTopY - promptH - 8;

      // Clamp so it doesn't go off-screen
      const maxLeft = container.scrollWidth - promptW - 8;
      left = Math.max(8, Math.min(left, maxLeft));
      top = Math.max(8, top);

      prompt.style.left = left + 'px';
      prompt.style.top = top + 'px';
      prompt.style.transform = 'none';
    }

    container.appendChild(backdrop);
    container.appendChild(prompt);
    _identifyOverlay = backdrop;

    // Position after a frame so prompt has dimensions
    requestAnimationFrame(() => {
      positionPrompt();
    });
  }

  // Main click handler
  container.addEventListener('click', (e) => {
    if (_identifyOverlay) return; // don't process clicks while identify prompt showing

    const clientX = e.clientX, clientY = e.clientY;
    const rect = wallpaper.getBoundingClientRect();
    const x = Math.round(((clientX - rect.left) / rect.width) * 1000) / 1000;
    const y = Math.round(((clientY - rect.top) / rect.height) * 1000) / 1000;
    const onSprite = isOnSprite(clientX, clientY);

    _clickCount++;
    if (_clickCount === 1) {
      _clickTimer = setTimeout(() => {
        sendTouch('click', x, y, onSprite);
        _clickCount = 0;
      }, 300);
    } else if (_clickCount >= 2) {
      clearTimeout(_clickTimer);
      _clickCount = 0;
      sendTouch('doubleclick', x, y, onSprite);
    }
  });

  // =========================================================================
  //  Wallpaper Load Handler ‚Äî reposition sprite once image dimensions are known
  // =========================================================================
  wallpaper.addEventListener('load', () => {
    const loc = resolveLocation(currentLoc, roomConfig);
    if (loc) positionSprite(loc);
  });

  // =========================================================================
  //  Init
  // =========================================================================
  pollState();
  setInterval(pollState, 2000);
  pollWeather();
  setInterval(pollWeather, 15 * 60 * 1000);
</script>
</body>
</html>
