<!--
  ============================================================================
  File:     dashboard/index.html
  Purpose:  Claudron Dashboard — "Claudron lives here"

  The main display for a 7" screen (1024×600). Shows Claudron's sprite in
  whatever room he's currently in, with mood-based face rendering, speech
  bubble for status text, and smooth animations.

  Polls /api/state every 2s for mood, status, room, and location changes.
  Polls /api/room/{room} when the room changes to get location configs.

  External Dependencies:
    /js/claudron-face.js                — Shared face rendering (renderFace)
    /sprites/body-final-transparent.png — Sprite body image
    /rooms/{room}/wallpaper.png         — Room background images
  ============================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claudron</title>
<style>
  /* ===== Reset & Base ===== */
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0f0f0f;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* ===== Room Container =====
     Maintains native wallpaper aspect ratio (1584×672 → 42.42%).
     Fills width, centered vertically. */
  #room-container {
    position: relative;
    width: 100%;
    max-width: 1584px;
    padding-top: 42.42%;
  }
  #room-wallpaper {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    transition: opacity 0.5s ease;
  }

  /* ===== Sprite Anchor =====
     Absolutely positioned within room container.
     Transitions smoothly when location changes. */
  #sprite-anchor {
    position: absolute;
    display: none;
    flex-direction: column;
    align-items: center;
    transition: left 0.6s ease, top 0.6s ease;
  }

  /* ===== Cute 8-bit Font ===== */
  @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

  /* ===== Speech Bubble (Stardew/Animal Crossing style) ===== */
  #speech-bubble {
    position: absolute;
    z-index: 10;
    background: rgba(245, 240, 230, 0.95);
    border: 2.5px solid #8B6FCF;
    border-radius: 14px;
    padding: 7px 14px;
    max-width: 400px;
    white-space: nowrap;
    transform: translateX(-50%);
    font-family: 'VT323', monospace;
    font-size: 12px;
    letter-spacing: 0.5px;
    line-height: 1.3;
    color: #2a1a3e;
    text-align: center;
    box-shadow: 0 2px 8px rgba(139, 111, 207, 0.3), inset 0 0 0 1px rgba(255,255,255,0.3);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  #speech-bubble.visible { opacity: 1; }
  /* Cute rounded tail */
  #speech-bubble::after {
    content: '';
    position: absolute;
    bottom: -7px;
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    width: 10px; height: 10px;
    background: rgba(245, 240, 230, 0.95);
    border-right: 2.5px solid #8B6FCF;
    border-bottom: 2.5px solid #8B6FCF;
  }

  /* ===== Sprite Wrapper ===== */
  #sprite-wrap {
    position: relative;
    width: 200px;
    height: 183px;
    transform-origin: top center;
  }
  #sprite-wrap img {
    position: absolute;
    top: 0; left: 0;
    width: 200px; height: 183px;
  }
  #face-container {
    position: absolute;
    top: 0; left: 0;
    width: 200px; height: 183px;
    pointer-events: none;
  }

  /* ===== Animations ===== */
  @keyframes bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
  }
  @keyframes glowGreen {
    0%, 100% { filter: drop-shadow(0 0 8px rgba(74, 222, 128, 0.65)); }
    50% { filter: drop-shadow(0 0 18px rgba(74, 222, 128, 0.85)); }
  }
  @keyframes glowRed {
    0%, 100% { filter: drop-shadow(0 0 8px rgba(255, 68, 68, 0.65)); }
    50% { filter: drop-shadow(0 0 18px rgba(255, 68, 68, 0.85)); }
  }

  /* Mood-based sprite states */
  .mood-normal #sprite-anchor { animation: bob 3s ease-in-out infinite; }
  .mood-normal #sprite-wrap  { animation: glowGreen 3s ease-in-out infinite; }

  .mood-angry #sprite-anchor { animation: bob 3s ease-in-out infinite; }
  .mood-angry #sprite-wrap   { animation: glowRed 3s ease-in-out infinite; }

  .mood-sleeping #sprite-anchor { animation: none; }
  .mood-sleeping #sprite-wrap   { animation: none; filter: none; opacity: 0.6; }

  /* ===== Editor Toggle ===== */
  #editor-btn {
    position: fixed;
    bottom: 10px;
    right: 10px;
    width: 36px;
    height: 36px;
    background: rgba(30, 30, 30, 0.7);
    border: 1px solid #333;
    border-radius: 50%;
    color: #888;
    font-size: 18px;
    cursor: pointer;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    transition: opacity 0.3s;
    opacity: 0.4;
  }
  #editor-btn:hover { opacity: 1; }
</style>
</head>
<body>

<!-- Room View -->
<div id="room-container">
  <img id="room-wallpaper" src="" alt="">
  <div id="speech-bubble"></div>
  <div id="sprite-anchor">
    <div id="sprite-wrap">
      <img id="sprite" src="/sprites/body-final-transparent.png" alt="">
      <div id="face-container"></div>
    </div>
  </div>
</div>

<!-- Editor Link -->
<a id="editor-btn" href="/editor.html" title="Open Editor">⚙️</a>

<script src="/js/claudron-face.js"></script>
<script>
  // =========================================================================
  //  Constants & State
  // =========================================================================
  const NATIVE_W = 1584, SPRITE_NATIVE = 250;

  let currentRoom = null;
  let currentLoc = null;
  let currentMood = null;
  let currentStatus = null;
  let roomConfig = null;

  // DOM refs
  const container = document.getElementById('room-container');
  const wallpaper = document.getElementById('room-wallpaper');
  const anchor    = document.getElementById('sprite-anchor');
  const wrap      = document.getElementById('sprite-wrap');
  const faceCtr   = document.getElementById('face-container');
  const bubble    = document.getElementById('speech-bubble');

  // =========================================================================
  //  Mood Class Management
  // =========================================================================

  /** Apply the correct mood class to <body> for CSS animation control. */
  function applyMoodClass(mood) {
    document.body.className = '';
    if (mood === 'sleeping') {
      document.body.classList.add('mood-sleeping');
    } else if (mood === 'angry') {
      document.body.classList.add('mood-angry');
    } else {
      document.body.classList.add('mood-normal');
    }
  }

  // =========================================================================
  //  Sprite Positioning
  // =========================================================================

  /**
   * Position the sprite at a location from the room config.
   * Uses the exact positioning math from the spec.
   */
  function positionSprite(loc) {
    if (!loc) { anchor.style.display = 'none'; return; }

    const containerWidth = container.offsetWidth;
    const spritePct = SPRITE_NATIVE / NATIVE_W * 100;
    const scale = (containerWidth * spritePct / 100) / 200;
    const scaledW = 200 * scale;
    const scaledH = 183 * scale;

    const facing = loc.facing || 'right';
    const rotation = loc.rotation || 0;

    anchor.style.display = 'flex';
    anchor.style.left = `calc(${loc.x * 100}% - ${scaledW / 2}px)`;
    anchor.style.top = `calc(${loc.y * 100}% - ${scaledH}px)`;
    // Position bubble centered above sprite's mouth area
    bubble.style.left = `calc(${loc.x * 100}% + ${scaledW * 0.16}px)`;
    bubble.style.top = `calc(${loc.y * 100}% - ${scaledH + 30}px)`;
    wrap.style.transform = `scale(${scale})${facing === 'left' ? ' scaleX(-1)' : ''}${rotation ? ` rotate(${rotation}deg)` : ''}`;
    wrap.style.transformOrigin = 'top center';
  }

  // =========================================================================
  //  Speech Bubble
  // =========================================================================

  function updateBubble(status) {
    if (status) {
      bubble.textContent = status;
      bubble.classList.add('visible');
    } else {
      bubble.classList.remove('visible');
    }
  }

  // =========================================================================
  //  Room Loading
  // =========================================================================

  async function loadRoom(room) {
    wallpaper.src = `/rooms/${room}/wallpaper.png`;
    try {
      const res = await fetch(`/api/room/${room}`);
      roomConfig = await res.json();
    } catch {
      roomConfig = { locations: {} };
    }
  }

  // =========================================================================
  //  State Polling — every 2 seconds
  // =========================================================================

  async function pollState() {
    try {
      const res = await fetch('/api/state');
      const state = await res.json();

      // Room changed? Reload room config
      if (state.room !== currentRoom) {
        currentRoom = state.room;
        await loadRoom(currentRoom);
      }

      // Location changed? Reposition sprite
      if (state.location !== currentLoc) {
        currentLoc = state.location;
        const loc = roomConfig?.locations?.[currentLoc];
        positionSprite(loc || null);
      }

      // Mood changed? Update face + animations
      if (state.mood !== currentMood) {
        currentMood = state.mood;
        applyMoodClass(currentMood);
        renderFace(faceCtr, currentMood);
      }

      // Status changed? Update speech bubble
      if (state.status !== currentStatus) {
        currentStatus = state.status;
        updateBubble(currentStatus);
      }
    } catch {
      // Silent fail — retry next poll
    }
  }

  // =========================================================================
  //  Resize Handler — reposition sprite when window resizes
  // =========================================================================
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      if (currentLoc && roomConfig?.locations?.[currentLoc]) {
        positionSprite(roomConfig.locations[currentLoc]);
      }
    }, 100);
  });

  // =========================================================================
  //  Init
  // =========================================================================
  pollState();
  setInterval(pollState, 2000);
</script>
</body>
</html>
